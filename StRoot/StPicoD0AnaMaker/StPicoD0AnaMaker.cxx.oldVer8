#include <iostream>
#include <fstream>
#include <string>
#include <cmath>

#include "TFile.h"
#include "TClonesArray.h"
#include "TTree.h"
#include "TNtuple.h"

#include "StPicoDstMaker/StPicoDstMaker.h"
#include "StPicoDstMaker/StPicoDst.h"
#include "StPicoDstMaker/StPicoEvent.h"
#include "StPicoDstMaker/StPicoTrack.h"

#include "StPicoD0EventMaker/StPicoD0Event.h"
#include "StPicoD0EventMaker/StKaonPion.h"

#include "StMixedEventBuffer/StMixedEventBuffer.h"
#include "StMixedEventBuffer/StMixerEvent.h"
#include "StMixedEventBuffer/StMixerTrack.h"

#include "StPicoD0AnaMaker.h"
#include "StPicoHFMaker/StHFCuts.h"


/****

Author: Alex Jentsch

Current version of AnaMaker (by date): 2/22/2016

Description of current functionality:

1. Can read in both Trees and PicoDst -> Stores all basic QA info for PicoDsts
2. Can make invMass Histos for various pt bins
3. Can produce sibling histograms for various pt bins


Still Needs:

1. Various BG production methods (side band, mixing, etc.)


Update (3/10/2016)

Currently adding event mixing to code. Using the StPicoMixedEventMaker as a baseline, but changing its implementation significantly.
I want to be able to handle all of the mixing in my AnaMaker with all of the mixing functions being used as if from any other normal class.


Update (3/31/2016)

Buffering code built and seems to function. Lots of testing left to do. Need to make sure the stored event information can be retrieved 
and can be binned into histograms.


Update (4/19/2016)

Event mixing is working and the buffering is not causing any problems. May be changing the event mixing algorithm to better the statistics.

****/

ClassImp(StPicoD0AnaMaker)

StPicoD0AnaMaker::StPicoD0AnaMaker(char const * name, char const * inputFilesList, 
                                   char const * outName, StPicoDstMaker* picoDstMaker): 
                            StMaker(name),mPicoDstMaker(picoDstMaker),mPicoD0Event(NULL),
                            mOutFileName(outName), mInputFileList(inputFilesList),
                            mOutputFile(NULL), mChain(NULL), mEventCounter(0), mHFCuts(NULL)
{}

//---------------------------------------Initialization-----------------------------------------
Int_t StPicoD0AnaMaker::Init()
{
   mPicoD0Event = new StPicoD0Event();

   mChain = new TChain("T");
   std::ifstream listOfFiles(mInputFileList.Data());
   if (listOfFiles.is_open())
   {
      std::string file;
      while (getline(listOfFiles, file))
      {
         LOG_INFO << "StPicoD0AnaMaker - Adding :" << file << endm;
         mChain->Add(file.c_str());
      }
   }
   else
   {
      LOG_ERROR << "StPicoD0AnaMaker - Could not open list of files. ABORT!" << endm;
      return kStErr;
   }

   mChain->GetBranch("dEvent")->SetAutoDelete(kFALSE);
   mChain->SetBranchAddress("dEvent", &mPicoD0Event);

   mOutputFile = new TFile(mOutFileName.Data(), "RECREATE");
   mOutputFile->cd();

   if (!mHFCuts)
    mHFCuts = new StHFCuts;   
   mHFCuts->init();
   
   
   //-----------------------FLAGS--------------------------------//
   DEBUG = true;
   DEBUG_MIX_BUFFER = true;
   USE_VZ_BINS = false;
   //----------------------------------------------------------//
   
   //---------------------Important constants-----------------//
   BUFFER_SIZE = 5;
   
   
   // --------------------Event Mixer Buffer-------------------------------------
   
    if(USE_VZ_BINS) { nVzBins = 10; }  //flag to set binning on Vz
    else nVzBins = 1;
    
    for(int i = 0; i < 11; i++){
        for( int j = 0; j < nVzBins; j++){
        
            
            eventBufferUS[j][i] = new StMixedEventBuffer();
            eventBufferUS[j][i]->setBufferSize(BUFFER_SIZE);            //set buffer size here -- the amount of events in each 2d bin
            eventBufferUS[j][i]->setBufferCounter(0);
            
        }
   }    
   
    for(int i = 0; i < 11; i++){
        for( int j = 0; j < nVzBins; j++){
        
            
            eventBufferLS[j][i] = new StMixedEventBuffer();
            eventBufferLS[j][i]->setBufferSize(BUFFER_SIZE);            //set buffer size here -- the amount of events in each 2d bin
            eventBufferLS[j][i]->setBufferCounter(0);
            
        }
   }    
   
    
   //--------------------CUTS------------------------------------------
   
   
   
    /*ptRange[6] = {0.0, 1.0, 2.0, 3.0, 5.0, 10.0};
    decayLengthCuts[5] = {.0145, .0181, .0212, .0247, .0259};
    daughterDCACuts[5] = {.0084, .0066, .0057, .0050, .0060};
    dcaKaonPV[5] = {.0103, .0091, .0095, .0079, .0058};
    dcaPionPV[5] = {.0110, .0111, .0086, .0081, .0062};
    dcaV0toPV[5] = {.0061, .0049, .0038, .0038, .0040};*/
    
    kaonPtCut      = .15;
    pionPtCut      = .15;
    
    D0InvMassLow   = 1.82;
    D0InvMassHigh  = 1.90;
    
    eventNumber = 1;
    
    TString VzBinLabel = "_VzBin_";
    
    TString sibCorrUSLabel1 = "Sibling_US_correlation";
    TString sibCorrUSLabel2 = "_CentBin_";
    
    TString mixCorrUSLabel1 = "Mixed_US_correlation";
    TString mixCorrUSLabel2 = "_CentBin_";
    
    TString sibCorrLSLabel1 = "Sibling_LS_correlation";
    TString sibCorrLSLabel2 = "_CentBin_";
    
    TString mixCorrLSLabel1 = "Mixed_LS_correlation";
    TString mixCorrLSLabel2 = "_CentBin_";
    
    TString eventCounterLabel = "Event Count Vz ";
    
    TString str1;
    TString str2;
    TString str3;
    TString str4;
    
    TString binLabelVz[10] = {"0", "1", "2", "3", "4", "5", "6", "7", "8","9"};
    TString binLabelCent[11] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"};
   
   // --------------------Begin User Variables-----------------------------------
   
   //ptDist          = new TH1D("Pt Distribution", "Pt Distribution", 1000, 0, 10);              
   invMass         = new TH1D("unlikeSign", "unlikeSign", 50, 1.6, 2.1);
   kaonDist        = new TH1D("Kaon Distribution", "Kaon Distribution", 500, 0 , 500);
   pionDist        = new TH1D("Pion Distribution", "Pion Distribution", 2000, 0 , 2000);
   likeSignBG      = new TH1D("LikeSignBG", "LikeSignBG", 50, 1.6, 2.1);
   invMassMinusBG  = new TH1D("D0MinusLSBG", "D0MinusLSBG", 50, 1.6, 2.1);
   
   
   //Sibling Correlation Histograms
   
   
   
   
   for(int i = 0; i < nVzBins; i++){ //Initialize all of the histograms for storing the sibling and mixed information
        for(int j = 0; j < 11; j++){
        
            if(USE_VZ_BINS){
                
                str1 = sibCorrUSLabel1 + VzBinLabel + binLabelVz[i] + sibCorrUSLabel2 + binLabelCent[j];
                str2 = mixCorrUSLabel1 + VzBinLabel + binLabelVz[i] + mixCorrUSLabel2 + binLabelCent[j];
                str3 = sibCorrLSLabel1 + VzBinLabel + binLabelVz[i] + sibCorrLSLabel2 + binLabelCent[j];
                str4 = mixCorrLSLabel1 + VzBinLabel + binLabelVz[i] + mixCorrLSLabel2 + binLabelCent[j];
            
            } 
             
            else { 
                   
                   str1 = sibCorrUSLabel1 + sibCorrUSLabel2 + binLabelCent[j];
                   str2 = mixCorrUSLabel1 + mixCorrUSLabel2 + binLabelCent[j];
                   str3 = sibCorrLSLabel1 + sibCorrLSLabel2 + binLabelCent[j];
                   str4 = mixCorrLSLabel1 + mixCorrLSLabel2 + binLabelCent[j]; 
            } 
             
            sibCorrBinUS[i][j]       = new TH2D(str1, str1, 25, -2, 2, 25, -TMath::PiOver2(), 3*TMath::PiOver2());
            mixCorrBinUS[i][j]       = new TH2D(str2, str2, 25, -2, 2, 25, -TMath::PiOver2(), 3*TMath::PiOver2());
            sibCorrBinLS[i][j]       = new TH2D(str3, str3, 25, -2, 2, 25, -TMath::PiOver2(), 3*TMath::PiOver2());
            mixCorrBinLS[i][j]       = new TH2D(str4, str4, 25, -2, 2, 25, -TMath::PiOver2(), 3*TMath::PiOver2());
        }
   }    
   
   for(int i = 0; i < nVzBins; i++){
    
        if(USE_VZ_BINS) { str1 = eventCounterLabel + binLabelVz[i]; }
        
        else str1 = "event count per centrality bin (for events containing D0s)";
        
        eventCategoryCounter[i] = new TH1D(str1, str1, 11, 0, 11);
        eventCategoryCounter[i]->GetXaxis()->SetTitle("CentralityBin");
   }        
   
   
   //Mixed event histograms
   
   mixedEventTest = new TH1D("mixed event test", "mixed event test", 2000, 0, 1999);
   mixedHadronPtDist  = new TH1D("mixed Hadron pt", "mixed Hadron pt", 1000, 0, 10);
   mixedHadronPhiDist = new TH1D("mixed Hadron Phi", "mixed Hadron Phi", 1000, -2*TMath::Pi(), 2*TMath::Pi());
   mixedHadronEtaDist = new TH1D("mixed Hadron Eta", "mixed Hadron Eta", 1000, -1, 1);
   mixedEventKPInvMass = new TH1D("mixed event KP inv mass", "mixed event KP inv mass", 50, 1.6, 2.1);
   
   //QA Histograms
   eventCounter    = new TH1D("number of events used", "number of events used", 4, 0, 4);
   trackCounter    = new TH1D("number of tracks per event", "number of tracks per event", 2000, 0, 1999);
   kaonPtDist      = new TH1D("Kaon Pt Distribution", "Kaon Pt Distribution", 1000, 0, 5);
   pionPtDist      = new TH1D("Pion Pt Distribution", "Pion Pt Distribution", 1000, 0, 5);
   kaonEtaDist     = new TH1D("Kaon Eta Distribution", "Kaon Eta Distribution", 1000, -1, 1);
   pionEtaDist     = new TH1D("Pion Eta Distribution", "Pion Eta Distribution", 1000, -1, 1);
   kaonPhiDist     = new TH1D("Kaon Phi Distribution", "Kaon Phi Distribution", 1000, -2*TMath::Pi(), 2*TMath::Pi());
   pionPhiDist     = new TH1D("Pion Phi Distribution", "Pion Phi Distribution", 1000, -2*TMath::Pi(), 2*TMath::Pi());
   kaonDCAprimary  = new TH1D("DCA kaons from primary", "DCA kaons from primary", 500, 0.0, 0.5);
   pionDCAprimary  = new TH1D("DCA pions from primary", "DCA pions from primary", 500, 0.0, 0.5);
   
   hadronPtDist    = new TH1D("Inclusive Hadron pt", "Inclusive Hadron pt", 1000, 0, 10);
   hadronPhiDist   = new TH1D("Inclusive Hadron Phi", "Inclusive Hadron Phi", 1000, -2*TMath::Pi(), 2*TMath::Pi());
   hadronEtaDist   = new TH1D("Inclusvie Hadron Eta", "Inclusive Hadron Eta", 1000, -1, 1);
   
   kaonDCAfromD0   = new TH1D("DCA for kaons from D0", "DCA for kaons from D0", 500, 0.0, 0.5);
   pionDCAfromD0   = new TH1D("DCA for pions from D0", "DCA for pions from D0", 500, 0.0, 0.65);
   decayLengthQA   = new TH1D("D0 Candidate Decay Length (no mass cut)", "D0 Candidate Decay Length (no mass cut)", 500, 0.0, 1.5);
   pointingAngleQA = new TH1D("D0 Candidate Pointing Angle(no mass cut)", "D0 Candidate Pointing Angle (no mass cut)", 500, 0.0, 1.7);
   daughterDCAQA   = new TH1D("D0 Daughter DCA", "D0 Daughter DCA (no mass cut)", 500, 0.0, .01);

   //QA for mass-cut D0  
   D0ptDist        = new TH1D("D0 Candidate pt Dist (mass cut)", "D0 Candidate pt Dist (mass cut)", 1000, 0, 10);
   D0EtaDist       = new TH1D("D0 Eta Dist", "D0 #eta Dist. (mass cut)", 500, -1, 1);
   D0PhiDist       = new TH1D("D0 Phi Dist", "D0 #phi Dist. (mass cut)", 500, -2*TMath::Pi(), 2*TMath::Pi());
   D0PeakPlusBG    = new TH1D("D0PeakPlusBG", "D0PeakPlusBG", 50, 1.6, 2.1);
   D0LikeSignBG    = new TH1D("LikeSign peak range", "LikeSign peak range", 50, 1.6, 2.1);
   D0PeakMinusBG   = new TH1D("D0Peak", "D0Peak", 50, 1.6, 2.1);
   d0CountPerEvent = new TH1I("number of D0 candidates per event", "number of D0 candidates per event", 50, 0, 50);
   
   //Histogram formatting

   eventCounter->GetXaxis()->SetBinLabel(1,"minBias+D0 Cand.");
   eventCounter->GetXaxis()->SetBinLabel(2,"minBias");
   eventCounter->GetXaxis()->SetBinLabel(3,"total");
   eventCounter->GetXaxis()->SetBinLabel(4,"events from bad runs");
   
//----------------------End User Variables------------------------------------
   
   
   
   
   
   return kStOK;
}

//-----------------------------------------------------------------------------

//------------------------------------Destructor------------------------------
StPicoD0AnaMaker::~StPicoD0AnaMaker()
{
   /*  */
}
//-----------------------------------------------------------------------------

//------------------------------------Finish-----------------------------------
Int_t StPicoD0AnaMaker::Finish()
{
   LOG_INFO << " StPicoD0AnaMaker - writing data and closing output file " <<endm;
   mOutputFile->cd();
   // save user variables here
   
   StMixerEvent* event;
   StMixerTrack mixedTrack;
   StMixerTrack kaonPionTrack;
   int nTracks = 0;
   //int nVzBins = 1;
   
   //if(USE_VZ_BINS) { nVzBins = 10; }
   
   
   for(int i = 0; i < nVzBins; i++){
        for(int j = 0; j < 11; j++){
        
            sibCorrBinUS[i][j]->Write();
            mixCorrBinUS[i][j]->Write();
            sibCorrBinLS[i][j]->Write();
            mixCorrBinLS[i][j]->Write();
            
            if(DEBUG){ cout << "deleting buffer[" << i << "][" << j << "]" << endl;}
            
            delete eventBufferUS[i][j];
            delete eventBufferLS[i][j];
            
        }
   }    
  
   //ptDist->Write();
   invMass->Write();
   kaonDist->Write();
   pionDist->Write();
   likeSignBG->Write();
   
   invMassMinusBG->Write();
   D0EtaDist->Write();
   D0PhiDist->Write();
   D0PeakMinusBG->Write();
   eventCounter->Write();
   kaonDCAfromD0->Write();
   pionDCAfromD0->Write();
   decayLengthQA->Write();
   pointingAngleQA->Write();
   daughterDCAQA->Write();
   D0ptDist->Write();   
   kaonPtDist->Write();
   pionPtDist->Write();
   kaonEtaDist->Write();
   pionEtaDist->Write();
   kaonPhiDist->Write();
   pionPhiDist->Write();
   kaonDCAprimary->Write();
   pionDCAprimary->Write();
     
   
   hadronPtDist->Write();
   hadronPhiDist->Write();
   hadronEtaDist->Write();
  
   D0PeakPlusBG->Write();
   D0LikeSignBG->Write();
   trackCounter->Write();
   
   if(DEBUG){
        mixedEventTest->Write();
        mixedHadronPtDist->Write();
        mixedEventKPInvMass->Write();
   }
   
  
   d0CountPerEvent->Write();
   
   for(int i = 0; i < nVzBins; i++){
   
        eventCategoryCounter[i]->Write();
        
   }     
   
   //siblingCorr->Write();

   mOutputFile->Close();
  

   return kStOK;
}
//-----------------------------------------------------------------------------

//----------------------------------Make---------------------------------------
Int_t StPicoD0AnaMaker::Make(){ //begin Make member function
   readNextEvent();

   if (!mPicoDstMaker)
   {
      LOG_WARN << " StPicoD0AnaMaker - No PicoDstMaker! Skip! " << endm;
      return kStWarn;
   }

   StPicoDst const* picoDst = mPicoDstMaker->picoDst();


   if (!picoDst)
   {
      LOG_WARN << "StPicoD0AnaMaker - No PicoDst! Skip! " << endm;
      return kStWarn;
   }

   if(mPicoD0Event->runId() != picoDst->event()->runId() ||
       mPicoD0Event->eventId() != picoDst->event()->eventId())
   {
     LOG_ERROR <<" StPicoD0AnaMaker - !!!!!!!!!!!! ATTENTION !!!!!!!!!!!!!"<<endm;
     LOG_ERROR <<" StPicoD0AnaMaker - SOMETHING TERRIBLE JUST HAPPENED. StPicoEvent and StPicoD0Event are not in sync."<<endm;
     exit(1);
   }

   //-------------------Begin User Analysis---------------------------
 
/****************************************************************************************************************/
/****************************GLOBAL AND LOCAL VARIABLES SET AND INITIALIZED BEGIN*********************************/  
/***************************************************************************************************************/ 
    
    
    //-------------- Various global cuts and pt ranges---------------- 
    
    kaonPtCut      = .15;
    pionPtCut      = .15;
    
    D0InvMassLow   = 1.82;
    D0InvMassHigh  = 1.90;
    
    trackCount = 0;
    centralityBin = 0;  //This number will be between 0 and 8 -- 9 bins total
    
    VzBin = 0;
	
    //--------------Local Variables used in the code-------------------
    double delPhi         = 0;
    double delEta         = 0;
    double pt             = 0;
    double phi            = 0;
    double eta            = 0;
    int    pairCharge     = 0;
    int    PIDflag        = 0;
    
    StPicoTrack* trk;
    StThreeVectorF trackMom;
    double bField         = picoDst->event()->bField();
    StThreeVectorF pVtx   = picoDst->event()->primaryVertex();
    StThreeVectorF kaonPionMom;
    
    bool USEventStoredInBuffer  = false;
    bool LSEventStoredInBuffer  = false;
    int d0Counter = 0;
    
/****************************************************************************************************************/
/****************************GLOBAL AND LOCAL VARIABLES SET AND INITIALIZED END********************************/  
/***************************************************************************************************************/   
    
 
/****************************************************************************************************************/
/****************************PRELIMINARY EVENT CUTS BEGIN********************************************************/  
/***************************************************************************************************************/    
 
    if(!mHFCuts->isGoodRun(picoDst->event())){
      
        eventCounter->Fill(2);
        eventCounter->Fill(3);
        return kStOk; //makes sure the event comes from good run
    }

    eventCounter->Fill(2);
    if(!picoDst->event()->isMinBias()) {return kStOK;}          //min bias event flag
  
    eventCounter->Fill(1);

    if(mPicoD0Event->nKaons() > 0){ kaonDist->Fill(mPicoD0Event->nKaons());}
    if(mPicoD0Event->nPions() > 0){ pionDist->Fill(mPicoD0Event->nPions());}

    TClonesArray const * aKaonPion = mPicoD0Event->kaonPionArray();    //The Kaon-Pion list is generated here

    trackCount = picoDst->numberOfTracks();            //NEED TO CHECK THIS TRACK COUNT INFORMATION
   
   
    trackCounter->Fill(picoDst->numberOfTracks());
   
    centralityBin = getCentralityBin(trackCount);  //get centrality bin 
   
    if(USE_VZ_BINS){
        Vz = picoDst->event()->primaryVertex().z();
        VzBin         = getVzBin(Vz);                  //get Vz bin
    }
   
    else VzBin = 0;
   
    if(centralityBin == -1 || VzBin == -1) { return kStOk; }
   
   

/****************************************************************************************************************/
/****************************PRELIMINARY EVENT CUTS END********************************************************/  
/***************************************************************************************************************/ 
  
  
/****************************************************************************************************************/  
/********************QA Loop for storing all of the basic information about the events and tracks BEGIN**********/
/****************************************************************************************************************/   
   
    for(unsigned int i = 0; i < picoDst->numberOfTracks(); ++i){ // Begin QA loop

          trk = picoDst->track(i);
          trackMom = trk->gMom(pVtx, bField);
          
          pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y()));
          phi = TMath::ATan2(trackMom.y(),trackMom.x());  
          eta = trackMom.pseudoRapidity();
          
          //if(pt<.15){continue;}                                                   //Basic cut to ensure the tracks are in the TPC acceptance.
          
          hadronPtDist->Fill(pt);                                                 //Fill pt dist. for all hadrons
          hadronPhiDist->Fill(phi);                                               //fill hists with phi and eta of hadrons for QA
          hadronEtaDist->Fill(eta);
   
          if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaKaon()) < 2.0)){       //ONLY check nSigma for TPC track -- used to be mHFCuts->isTPCKaon(trk), but this include pt cut
                                                                                  //need to fix this. Need to figure out how to access the nSigma from the cuts
                kaonPtDist->Fill(pt);
                kaonEtaDist->Fill(eta);
                kaonPhiDist->Fill(phi);
               // kaonDCAprimary->Fill(      
                continue;
          }

          if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaPion()) < 3.0)){     //ONLY check nSigma for TPC track
                
                pionPtDist->Fill(pt);
                pionEtaDist->Fill(eta);
                pionPhiDist->Fill(phi);
               // pionDCAprimary->Fill(
                continue;
          }
    }// end QA Loop
   
/****************************************************************************************************************/  
/********************QA Loop for storing all of the basic information about the events and tracks END**********/
/****************************************************************************************************************/  

//Still need to add checks for TOF information-----   

/****************************************************************************************************************/  
/***************************************LOOP TO STORE EVENTS IN MIXER BEGIN***************************************/
/****************************************************************************************************************/   
   
    for (int idx = 0; idx < aKaonPion->GetEntries(); ++idx){//begin loop to check if event can be used (check if a D0 exists)
   
        StKaonPion const* kp = (StKaonPion*)aKaonPion->At(idx);
        StPicoTrack const* kaon = picoDst->track(kp->kaonIdx());
        StPicoTrack const* pion = picoDst->track(kp->pionIdx());
                    
                    //  ptmin ptmax   decayLenMin&Max   daughterDCA kaon/pion pt kaon/pion DCA  DCA to PV
        if(!isGoodPair(kp)) continue;             
        if(!cutCheck(kp, 0.15,  20.0,  .0200,  999999.0,  .0055,  1.2,  1.2,  .008,  .008,  .0065)) { continue; } // do not add a kp pair (LS or US) that doesn't have the right stuff
        
        if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh){ 
            
            if(pion->charge()*kaon->charge() < 0 && !USEventStoredInBuffer){ //If an US pair exists and the event was not previously stored, store it
            
                eventBufferUS[VzBin][centralityBin]->addEvent(picoDst);
                USEventStoredInBuffer = true;
            }
            
            else if(pion->charge()*kaon->charge() > 0 && !LSEventStoredInBuffer){ //If a LS pair exists and the event was not previously stored, store it
            
                eventBufferLS[VzBin][centralityBin]->addEvent(picoDst);
                LSEventStoredInBuffer = true;
            }
             
        }
   
    }//end loop to check if event can be used (check if a D0 exists)
   
    if(!(USEventStoredInBuffer || LSEventStoredInBuffer)) { return kStOk; }  //If this event was not stored in the buffer, it did not pass basic event check -- skip
   
    if(DEBUG){ //This conditional would only trip if we made it past the previous conditional -- this means the event was stored
                cout << endl << endl;
                cout << "*********************EVENT START******************" << endl;
                cout << "We are on event # " << eventNumber << endl;
                cout << "This event has " << trackCount << " tracks." << endl;
                if(USE_VZ_BINS){ cout << "Vz: " << Vz << "   VzBin: " << VzBin << "    Centrality Bin: " << centralityBin << endl; }
                else cout << "Centrality Bin: " << centralityBin << endl;
                cout << endl;
                cout << "event " << eventNumber << " stored." << endl;
                cout << endl;
                //cout << "D0 candidate stats that tripped the event mixer: " << endl;
                //cout << "Mass: "<< kp->m() << "       US (-1) or LS (1): " << kaon->charge()*pion->charge() << endl;
                //cout << endl;
                eventNumber++;
            }
            eventCategoryCounter[VzBin]->Fill(centralityBin);
            eventCounter->Fill(0);
   
    
   
   //This block stores the tracks in the buffer and then stores the kaonPion pairs in the buffer in a separate list
    if(USEventStoredInBuffer || LSEventStoredInBuffer){
    
        if(USEventStoredInBuffer){// begin conditional for US
        
            for(unsigned int i = 0; i < picoDst->numberOfTracks(); ++i){//begin loop to add picoDST tracks to US event
    
                trk = picoDst->track(i);                                                             
                trackMom = trk->gMom(pVtx, bField); 
                //add 
                if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaKaon()) < 2.0)){ PIDflag = 1; }
                else if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaPion()) < 3.0)) { PIDflag = 2; }
                else PIDflag = 0;
            
                eventBufferUS[VzBin][centralityBin]->addTrackToEvent(eventBufferUS[VzBin][centralityBin]->getBufferIndex()-1, trackMom, trk->charge(), PIDflag);   //0 -- any hadron, 1 -- kaon, 2 -- pion
                  
            }//end loop to add picoDST tracks to US event
        }// end conditional for US
        
        if(LSEventStoredInBuffer){//begin conditional for LS
        
            for(unsigned int i = 0; i < picoDst->numberOfTracks(); ++i){//begin loop to add picoDST tracks to LS event
    
                trk = picoDst->track(i);                                                             
                trackMom = trk->gMom(pVtx, bField); 
                //add 
                if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaKaon()) < 2.0)){ PIDflag = 1; }
                else if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaPion()) < 3.0)) { PIDflag = 2; }
                else PIDflag = 0;
            
                eventBufferLS[VzBin][centralityBin]->addTrackToEvent(eventBufferLS[VzBin][centralityBin]->getBufferIndex()-1, trackMom, trk->charge(), PIDflag);   //0 -- any hadron, 1 -- kaon, 2 -- pion
                  
            }//end loop to add picoDST tracks to LS event
        }//end conditional for LS
        
        int i = 0;
        //int buffIdx = 0;
        
        for (int idx = 0; idx < aKaonPion->GetEntries(); ++idx){//begin loop to add kaonPions to event
   
            StKaonPion const* kp = (StKaonPion*)aKaonPion->At(idx);
            StPicoTrack const* kaon = picoDst->track(kp->kaonIdx());
            StPicoTrack const* pion = picoDst->track(kp->pionIdx());
   
            if(!isGoodPair(kp)) continue; 
            if(!cutCheck(kp, 0.15,  20.0,  .0200,  999999.0,  .0055,  1.2,  1.2,  .008,  .008,  .0065)) { continue; }
            
            if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh){ 
                
                kaonPionMom.set(kp->lorentzVector().px(),kp->lorentzVector().py(),kp->lorentzVector().pz());
                pairCharge = kaon->charge()*pion->charge(); //THIS IS NOT THE ACTUAL CHARGE -- SIMPLY THE US/LS VALUE
                if(pairCharge < 0 ){
                    
                    eventBufferUS[VzBin][centralityBin]->addKaonPionToEvent(eventBufferUS[VzBin][centralityBin]->getBufferIndex()-1, kaonPionMom, kp->m(), kp->kaonIdx(), kp->pionIdx(), pairCharge);
                }
                
                else if(pairCharge > 0){
                
                    eventBufferLS[VzBin][centralityBin]->addKaonPionToEvent(eventBufferLS[VzBin][centralityBin]->getBufferIndex()-1, kaonPionMom, kp->m(), kp->kaonIdx(), kp->pionIdx(), pairCharge);
                
                }
                
                if(DEBUG_MIX_BUFFER){ 
                    
                    cout << "Actual eta from picoDst: " << kp->eta() << endl;
                    
                    cout << "KaonPion charge from event info(LS or US): " << kaon->charge()*pion->charge() << endl;
                    cout << "KaonPion mass: " << kp->m() << endl;
                    cout << "_______________________________________________" << endl;
                    cout << endl;
                    
                    
                }    
                
                /*if(DEBUG_MIX_BUFFER){
                    buffIdx  = eventBufferUS[VzBin][centralityBin]->getBufferIndex()-1;
                    cout << "eta from buffer: " << eventBufferUS[VzBin][centralityBin]->getEvent(buffIdx)->getKaonPionAt(i).gMom().pseudoRapidity() << endl;
                    cout << "Kaon buffer index: " << eventBufferUS[VzBin][centralityBin]->getEvent(buffIdx)->getKaonPionAt(i).kaonIdx() << "    Pion buffer index: " << eventBufferUS[VzBin][centralityBin]->getEvent(buffIdx)->getKaonPionAt(i).pionIdx() << endl;
                    cout << "______________________________________________________" << endl;
                } */  
                
                i++;               
            }
   
        }//end loop to add kaonPions to event
        
    } //eventStoredInBuffer tag
   
   //cout << "total kp candidates stored: " << << endl;
   
/****************************************************************************************************************/  
/***************************************LOOP TO STORE EVENTS IN MIXER END***************************************/
/****************************************************************************************************************/   
   
/****************************************************************************************************************/   
/*****************************************BEGIN MAIN SIBLING LOOP************************************************/
/****************************************************************************************************************/
   
    for (int idx = 0; idx < aKaonPion->GetEntries(); ++idx){ // begin main sibling loop
     
        StKaonPion const* kp = (StKaonPion*)aKaonPion->At(idx);
    
        StPicoTrack const* kaon = picoDst->track(kp->kaonIdx());
        StPicoTrack const* pion = picoDst->track(kp->pionIdx());
      
        if(!isGoodPair(kp)) continue;   
        if(!cutCheck(kp, 0.15,  20.0,  .0200,  999999.0,  .0055,  1.2,  1.2,  .008,  .008,  .0065)) { continue; } //enforce D0 quality cuts      
      
     ////////////////Fill QA Histograms from pair trees //////////////////////

        kaonDCAfromD0->Fill(kp->kaonDca());
        pionDCAfromD0->Fill(kp->pionDca());
        decayLengthQA->Fill(kp->decayLength());
        pointingAngleQA->Fill(kp->pointingAngle());
        daughterDCAQA->Fill(kp->dcaDaughters());

     /////////////////////////////////////////////////////////////////////////
     
        if(kaon->charge()*pion->charge() < 0){// begin Unlike-sign conditional 
	      
            invMass->Fill(kp->m());     
            if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh) { D0PeakPlusBG->Fill(kp->m()); } 
             
	    }//end Unlike-sign conditional 
      
	  
        if(kaon->charge()*pion->charge() > 0){//begin Like-sign conditional 
          
            likeSignBG->Fill(kp->m());   
            if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh) { D0LikeSignBG->Fill(kp->m()); }
          
        }//end Like-sign conditional 
 
            
    /****************************************************************************************************************/
    /****************************SIBLING EVENT PAIRS FORMATIION BEGINS HERE*****************************************/  
    /***************************************************************************************************************/     
        
	    if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh){ // begin loop over both unlike-sign AND LIKE SIGN D0 candidates //&& kaon->charge()*pion->charge() < 0

            if(kaon->charge()*pion->charge() < 0){
                d0Counter = d0Counter + 1;
                D0ptDist->Fill(kp->pt()); 
                D0EtaDist->Fill(kp->eta());
                D0PhiDist->Fill(kp->phi());
            }
           
            for(unsigned int i = 0; i < picoDst->numberOfTracks(); ++i){ // begin picoDST loop for d0-hadron correlations
           
         	    if(i == kp->kaonIdx() || i == kp->pionIdx()) { continue; }    // Need to check this -- should avoid doing correlations with a D0 candidate daughter
             
                    ////////NEED TO ADD SOMETHING TO REJECT ELECTRONS AND MUONS///////////
                trk = picoDst->track(i);                                   //extract track from picoDst and store as StPicoTrack
           	    trackMom = trk->gMom(pVtx, bField);
               
                pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); //calculate tranverse momentum of track
                    
                    //if(pt < 1.0 ) { continue; }                           //Ensure track is within TPC acceptance and choose a specific sample of hadrons.
                                                                                
                phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                eta = trackMom.pseudoRapidity();
                 
                delPhi = kp->phi()-phi;
                if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
             	    else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                 delEta =kp->eta()-eta;
                   
                 if(kaon->charge()*pion->charge() < 0){//Unlike Sign histograms
                    
                        sibCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
                 }     
                 else if(kaon->charge()*pion->charge() > 0){// like sign

                        sibCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                 } 
            
            } // end picoDST loop for d0-hadron correlations
        }// End d0 sibling conditional
    }// End main sibling loop

    /****************************************************************************************************************/
    /****************************SIBLING EVENT PAIRS FORMATIION ENDS HERE********************************************/  
    /****************************************************************************************************************/
    
/****************************************************************************************************************/   
/*****************************************END MAIN SIBLING LOOP**************************************************/
/****************************************************************************************************************/    
    
    
//------------------------------------------------------------------------------------------------------------------------//   
    
/***************************************************************************************************************/
/*************************************EVENT MIXING BEINGS HERE**************************************************/
/***************************************************************************************************************/
    


    if(eventBufferUS[VzBin][centralityBin]->getBufferMaxSize() == eventBufferUS[VzBin][centralityBin]->getBufferSize()){ //begin buffer-full US mixing conditional
    
        if(DEBUG){cout << "Mixing US events in Vz/Centrality Bin " << VzBin<< "/" << centralityBin << endl;}
    
        StMixerEvent* event1;
        StMixerEvent* event2;
        StMixerEvent* event3;
        
        StMixerTrack kaonPionTrack1;
        StMixerTrack mixedTrack2;
        StMixerTrack mixedTrack3;
        
        int nTracks1 = 0;
        int nTracks2 = 0;
        int nTracks3 = 0;
        
        
        for(int i = 0; i < eventBufferUS[VzBin][centralityBin]->getBufferSize(); i++){ //begin even buffer loop
            
            
            if( i < eventBufferUS[VzBin][centralityBin]->getBufferSize()-2)  //for 5 events, this means i is 0, 1, 2
            {
                event1 = eventBufferUS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferUS[VzBin][centralityBin]->getEvent(i+1);
                event3 = eventBufferUS[VzBin][centralityBin]->getEvent(i+2);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing events in buffer " << i << " with " << i+1 << "  and " << i+2 << endl;}
            }    
            
            else if(i == eventBufferUS[VzBin][centralityBin]->getBufferSize()-2)  //for 5 events, this means i is 3, 4, 0
            {
                event1 = eventBufferUS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferUS[VzBin][centralityBin]->getEvent(i+1);
                event3 = eventBufferUS[VzBin][centralityBin]->getEvent(0);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing events in buffer " << i << " with " << i+1 << "  and 0 " <<  endl;}
            }    
                
            else if(i == eventBufferUS[VzBin][centralityBin]->getBufferSize()-1)  //for 5 events, this means i is 4, 0, 1
            {
                event1 = eventBufferUS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferUS[VzBin][centralityBin]->getEvent(0);
                event3 = eventBufferUS[VzBin][centralityBin]->getEvent(1);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing US events in buffer " << i << " with 0 and 1 "<<  endl;}
            }    
            
            
           for (int idx = 0; idx < event1->getKaonPionListSize(); idx++){//begin loop over event 1 kaon-pion list
                
                kaonPionTrack1 = event1->getKaonPionAt(idx);
                StMixerTrack mixerKaon = event1->getTrack(kaonPionTrack1.kaonIdx());
                StMixerTrack mixerPion = event1->getTrack(kaonPionTrack1.pionIdx());
                
                
                if(kaonPionTrack1.mass() > D0InvMassLow && kaonPionTrack1.mass() < D0InvMassHigh){//begin D0 conditional  && mixerKaon.charge()*mixerPion.charge() < 0
                 
                    for(int j = 0; j < nTracks2; j++){//begin loop over event 2 tracks
                        
                        if(j == kaonPionTrack1.kaonIdx() || j == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack2 = event2->getTrack(j);                                                            
           	            trackMom = mixedTrack2.gMom();
               
                        
               
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta =kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        if(mixerKaon.charge()*mixerPion.charge() < 0){
                
                            //USmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
            
                        }
                        
                        /*if(mixerKaon.charge()*mixerPion.charge() > 0){

                            //LSmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }*/
                    
                    }//end loop over event 2 tracks
                    
                    
                    for(int k = 0; k < nTracks3; k++){//begin loop over event 3
                        
                        if(k == kaonPionTrack1.kaonIdx() || k == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack3 = event3->getTrack(k);                                                            
           	            trackMom = mixedTrack3.gMom();
                        
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta = kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        if(mixerKaon.charge()*mixerPion.charge() < 0){
                
                            //USmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }
                        
                        /*if(mixerKaon.charge()*mixerPion.charge() > 0){

                            //LSmixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }*/
                        
                        
                            
                    }//end loop over event 3 tracks
                
                }//end conditional for d0
                
            }//end loop over event 1 kaon-pion list
       
       }//end event buffer loop   
/********************************************************************END EVENT MIXER BLOCK*****************************************/    
      
      eventBufferUS[VzBin][centralityBin]->clearBuffer();
      eventBufferUS[VzBin][centralityBin]->setBufferCounter(0);
      
      if(DEBUG) { 
        
        cout << endl << endl;
        cout << "US buffer for Vz/centrality bin "<< VzBin << "/"<< centralityBin<< " cleared" << endl;
        cout << endl;
  
      }     
      
      
      

     }//end buffer-full US mixing conditional
     
     
     
     
     if(eventBufferLS[VzBin][centralityBin]->getBufferMaxSize() == eventBufferLS[VzBin][centralityBin]->getBufferSize()){ //begin buffer-full LS mixing conditional
    
        if(DEBUG){cout << "Mixing LS events in Vz/Centrality Bin " << VzBin<< "/" << centralityBin << endl;}
    
        StMixerEvent* event1;
        StMixerEvent* event2;
        StMixerEvent* event3;
        
        StMixerTrack kaonPionTrack1;
        StMixerTrack mixedTrack2;
        StMixerTrack mixedTrack3;
        
        int nTracks1 = 0;
        int nTracks2 = 0;
        int nTracks3 = 0;
        
        
        for(int i = 0; i < eventBufferLS[VzBin][centralityBin]->getBufferSize(); i++){ //begin event buffer loop
            
            
            if( i < eventBufferLS[VzBin][centralityBin]->getBufferSize()-2)  //for 5 events, this means i is 0, 1, 2
            {
                event1 = eventBufferLS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferLS[VzBin][centralityBin]->getEvent(i+1);
                event3 = eventBufferLS[VzBin][centralityBin]->getEvent(i+2);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing LS events in buffer " << i << " with " << i+1 << "  and " << i+2 << endl;}
            }    
            
            else if(i == eventBufferLS[VzBin][centralityBin]->getBufferSize()-2)  //for 5 events, this means i is 3, 4, 0
            {
                event1 = eventBufferLS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferLS[VzBin][centralityBin]->getEvent(i+1);
                event3 = eventBufferLS[VzBin][centralityBin]->getEvent(0);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing LS events in buffer " << i << " with " << i+1 << "  and 0 " <<  endl;}
            }    
                
            else if(i == eventBufferLS[VzBin][centralityBin]->getBufferSize()-1)  //for 5 events, this means i is 4, 0, 1
            {
                event1 = eventBufferLS[VzBin][centralityBin]->getEvent(i);
                event2 = eventBufferLS[VzBin][centralityBin]->getEvent(0);
                event3 = eventBufferLS[VzBin][centralityBin]->getEvent(1);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing LS events in buffer " << i << " with 0 and 1 "<<  endl;}
            }    
            
            
           for (int idx = 0; idx < event1->getKaonPionListSize(); idx++){//begin loop over event 1 kaon-pion list
                
                kaonPionTrack1 = event1->getKaonPionAt(idx);
                StMixerTrack mixerKaon = event1->getTrack(kaonPionTrack1.kaonIdx());
                StMixerTrack mixerPion = event1->getTrack(kaonPionTrack1.pionIdx());
                
                
                if(kaonPionTrack1.mass() > D0InvMassLow && kaonPionTrack1.mass() < D0InvMassHigh){//begin D0 conditional  && mixerKaon.charge()*mixerPion.charge() < 0
                 
                    for(int j = 0; j < nTracks2; j++){//begin loop over event 2 tracks
                        
                        if(j == kaonPionTrack1.kaonIdx() || j == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack2 = event2->getTrack(j);                                                            
           	            trackMom = mixedTrack2.gMom();
               
                        
               
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta =kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        /*if(mixerKaon.charge()*mixerPion.charge() < 0){
                
                            
                            mixCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
            
                        }*/
                        
                        if(mixerKaon.charge()*mixerPion.charge() > 0){

                            
                            mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }
                    
                    }//end loop over event 2 tracks
                    
                    
                    for(int k = 0; k < nTracks3; k++){//begin loop over event 3
                        
                        if(k == kaonPionTrack1.kaonIdx() || k == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack3 = event3->getTrack(k);                                                            
           	            trackMom = mixedTrack3.gMom();
                        
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                        eta = trackMom.pseudoRapidity();
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        delEta = kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        /*if(mixerKaon.charge()*mixerPion.charge() < 0){
                
                            
                            mixCorrBinUS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }*/
                        
                        if(mixerKaon.charge()*mixerPion.charge() > 0){

                            
                            mixCorrBinLS[VzBin][centralityBin]->Fill(delEta, delPhi);
                        
                        }
                        
                        
                            
                    }//end loop over event 3 tracks
                
                }//end conditional for d0
                
            }//end loop over event 1 kaon-pion list
       
       }//end event buffer loop   
/********************************************************************END EVENT MIXER BLOCK*****************************************/    
      
      eventBufferLS[VzBin][centralityBin]->clearBuffer();
      eventBufferLS[VzBin][centralityBin]->setBufferCounter(0);
      
      if(DEBUG) { 
        
        cout << endl << endl;
        cout << "buffer for LS Vz/centrality bin "<< VzBin << "/"<< centralityBin<< " cleared" << endl;
        cout << endl;
  
      }     
      
      
      

     }//end buffer-full LS mixing conditional
    
/***************************************************************************************************************/
/*************************************EVENT MIXING ENDS HERE****************************************************/
/***************************************************************************************************************/   
       
       
       
       d0CountPerEvent->Fill(d0Counter);
       invMassMinusBG->Add(invMass, likeSignBG, 1, -1);
       D0PeakMinusBG->Add(D0PeakPlusBG, D0LikeSignBG, 1, -1);
    
   if(DEBUG) { cout << endl << "***************EVENT END****************************" << endl; }
    
   //-------------------End Current Event Analysis--------------------------------
   
   return kStOK;

}//end Make member function







//---------------------User Functions-------------------------------------

bool StPicoD0AnaMaker::isGoodPair(StKaonPion const* const kp) const
{
  if(!kp) return false;

  StPicoTrack const* kaon = mPicoDstMaker->picoDst()->track(kp->kaonIdx());
  StPicoTrack const* pion = mPicoDstMaker->picoDst()->track(kp->pionIdx());

  //  To be replaced by mHFCuts->isGoodSecondaryVertexPair(kp))
  bool pairCuts = kp->m() > mHFCuts->cutSecondaryPairMassMin() && 
    kp->m() < mHFCuts->cutSecondaryPairMassMax() &&
    std::cos(kp->pointingAngle()) > mHFCuts->cutSecondaryPairCosThetaMin() &&
    kp->decayLength()  > mHFCuts->cutSecondaryPairDecayLengthMin() && 
    kp->decayLength()  < mHFCuts->cutSecondaryPairDecayLengthMax() &&
    kp->dcaDaughters() < mHFCuts->cutSecondaryPairDcaDaughtersMax();

  return (mHFCuts->isGoodTrack(kaon) && mHFCuts->isGoodTrack(pion) &&
	  mHFCuts->isTPCKaon(kaon) && mHFCuts->isTPCPion(pion) && 
	  pairCuts);

}


bool StPicoD0AnaMaker::cutCheck(StKaonPion const* const kp, double ptMin, double ptMax, double decayLengthMin, double decayLengthMax, 
                                                            double dcaDaughters, double kaonPtCut, double pionPtCut, 
                                                            double dcaKaon, double dcaPion, double dcaV0toPV) const
{
  if(!kp) return false;

  StPicoTrack const* kaon = mPicoDstMaker->picoDst()->track(kp->kaonIdx());
  StPicoTrack const* pion = mPicoDstMaker->picoDst()->track(kp->pionIdx());

  
      bool truthCuts = kp->pt() > ptMin && kp->pt() < ptMax &&
                       kp->decayLength() > decayLengthMin && 
                       kp->decayLength() < decayLengthMax &&
                       kp->dcaDaughters() < dcaDaughters  &&
                       kaon->gPt() > kaonPtCut && pion->gPt() > pionPtCut &&
                       kp->kaonDca() > dcaKaon && kp->pionDca() > dcaPion &&
                       kp->perpDcaToVtx() < dcaV0toPV;
  
      return truthCuts;

}


int StPicoD0AnaMaker::getCentralityBin(int nTracks){

    if(nTracks >= 2   && nTracks < 14)  { return 0;  }
    if(nTracks >= 14  && nTracks < 32)  { return 1;  }
    if(nTracks >= 34  && nTracks < 67)  { return 2;  }
    if(nTracks >= 67  && nTracks < 115) { return 3;  }
    if(nTracks >= 115 && nTracks < 183) { return 4;  }
    if(nTracks >= 183 && nTracks < 275) { return 5;  }
    if(nTracks >= 275 && nTracks < 392) { return 6;  }
    if(nTracks >= 392 && nTracks < 537) { return 7;  }
    if(nTracks >= 537 && nTracks < 720) { return 8;  }
    if(nTracks >= 720 && nTracks < 829) { return 9;  }
    if(nTracks >= 829)                  { return 10; }

    else return -1;

}    

int StPicoD0AnaMaker::getVzBin(double Vz){

    if(Vz >= -6.0  && Vz < -4.8)  { return 0;  }   //bin 0: -6 to -4.8
    if(Vz >= -4.8  && Vz < -3.6)  { return 1;  }      //bin 1: -4.8 to -3.6
    if(Vz >= -3.6  && Vz < -2.4)  { return 2;  }          //bin 2: -3.6 to -2.4
    if(Vz >= -2.4  && Vz < -1.2)  { return 3;  }      //bin 3: -2.4 to -1.2
    if(Vz >= -1.2  && Vz < 0)     { return 4;  }      //bin 4: -1.2 to 0
    if(Vz >= 0     && Vz < 1.2)   { return 5;  }
    if(Vz >= 1.2   && Vz < 2.4)   { return 6;  }
    if(Vz >= 2.4   && Vz < 3.6)   { return 7;  }
    if(Vz >= 3.6   && Vz < 4.8)   { return 8;  }
    if(Vz >= 4.8   && Vz < 6.0)   { return 9;  }
    

    else return -1;

}    






