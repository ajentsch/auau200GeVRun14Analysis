#include <iostream>
#include <fstream>
#include <string>
#include <cmath>

#include "TFile.h"
#include "TClonesArray.h"
#include "TTree.h"
#include "TNtuple.h"

#include "StPicoDstMaker/StPicoDstMaker.h"
#include "StPicoDstMaker/StPicoDst.h"
#include "StPicoDstMaker/StPicoEvent.h"
#include "StPicoDstMaker/StPicoTrack.h"

#include "StPicoD0EventMaker/StPicoD0Event.h"
#include "StPicoD0EventMaker/StKaonPion.h"

#include "StMixedEventBuffer/StMixedEventBuffer.h"
#include "StMixedEventBuffer/StMixerEvent.h"
#include "StMixedEventBuffer/StMixerTrack.h"

#include "StPicoD0AnaMaker.h"
#include "StPicoHFMaker/StHFCuts.h"


/****

Author: Alex Jentsch

Current version of AnaMaker (by date): 2/22/2016

Description of current functionality:

1. Can read in both Trees and PicoDst -> Stores all basic QA info for PicoDsts
2. Can make invMass Histos for various pt bins
3. Can produce sibling histograms for various pt bins


Still Needs:

1. Various BG production methods (side band, mixing, etc.)


Update (3/10/2016)

Currently adding event mixing to code. Using the StPicoMixedEventMaker as a baseline, but changing its implementation significantly.
I want to be able to handle all of the mixing in my AnaMaker with all of the mixing functions being used as if from any other normal class.


Update (3/31/2016)

Buffering code built and seems to function. Lots of testing left to do. Need to make sure the stored event information can be retrieved 
and can be binned into histograms.

****/

ClassImp(StPicoD0AnaMaker)

StPicoD0AnaMaker::StPicoD0AnaMaker(char const * name, char const * inputFilesList, 
                                   char const * outName, StPicoDstMaker* picoDstMaker): 
                            StMaker(name),mPicoDstMaker(picoDstMaker),mPicoD0Event(NULL),
                            mOutFileName(outName), mInputFileList(inputFilesList),
                            mOutputFile(NULL), mChain(NULL), mEventCounter(0), mHFCuts(NULL)
{}

//---------------------------------------Initialization-----------------------------------------
Int_t StPicoD0AnaMaker::Init()
{
   mPicoD0Event = new StPicoD0Event();

   mChain = new TChain("T");
   std::ifstream listOfFiles(mInputFileList.Data());
   if (listOfFiles.is_open())
   {
      std::string file;
      while (getline(listOfFiles, file))
      {
         LOG_INFO << "StPicoD0AnaMaker - Adding :" << file << endm;
         mChain->Add(file.c_str());
      }
   }
   else
   {
      LOG_ERROR << "StPicoD0AnaMaker - Could not open list of files. ABORT!" << endm;
      return kStErr;
   }

   mChain->GetBranch("dEvent")->SetAutoDelete(kFALSE);
   mChain->SetBranchAddress("dEvent", &mPicoD0Event);

   mOutputFile = new TFile(mOutFileName.Data(), "RECREATE");
   mOutputFile->cd();

   if (!mHFCuts)
    mHFCuts = new StHFCuts;   
   mHFCuts->init();

   // --------------------Event Mixer Buffer-------------------------------------
   
    
   
    eventBuffer[0][0] = new StMixedEventBuffer();
    eventBuffer[0][0]->setBufferSize(5);     //set buffer size here -- the amount of events in each 2d bin
    eventBuffer[0][0]->setBufferCounter(0);
   
    
   //--------------------CUTS------------------------------------------
   
   
   
    /*ptRange[6] = {0.0, 1.0, 2.0, 3.0, 5.0, 10.0};
    decayLengthCuts[5] = {.0145, .0181, .0212, .0247, .0259};
    daughterDCACuts[5] = {.0084, .0066, .0057, .0050, .0060};
    dcaKaonPV[5] = {.0103, .0091, .0095, .0079, .0058};
    dcaPionPV[5] = {.0110, .0111, .0086, .0081, .0062};
    dcaV0toPV[5] = {.0061, .0049, .0038, .0038, .0040};*/
    
    kaonPtCut      = .15;
    pionPtCut      = .15;
    
    D0InvMassLow   = 1.82;
    D0InvMassHigh  = 1.90;
    
    eventNumber = 1;
   
   // --------------------Begin User Variables-----------------------------------
   
   //ptDist          = new TH1D("Pt Distribution", "Pt Distribution", 1000, 0, 10);              
   invMass         = new TH1D("unlikeSign", "unlikeSign", 50, 1.6, 2.1);
   angCorrPhi      = new TH1D("#Delta Phi", "#Delta#phi", 25, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEta      = new TH1D("#Delta#Eta", "#Delta#eta", 25, -2 , 2);  
   kaonDist        = new TH1D("Kaon Distribution", "Kaon Distribution", 500, 0 , 500);
   pionDist        = new TH1D("Pion Distribution", "Pion Distribution", 2000, 0 , 2000);
   likeSignBG      = new TH1D("Like Sign BG", "Like Sign BG", 50, 1.6, 2.1);
   invMassMinusBG  = new TH1D("D0 minus LS BG", "D0 minus LS BG", 50, 1.6, 2.1);
   angCorr2DAll    = new TH2D("2D Ang Corr", "2D Ang Corr", 25, -2, 2, 25, -TMath::PiOver2(), 3*TMath::PiOver2());
   
   siblingCorr     = new TH2D("Sibling corr -- no scaling", "Sibling corr -- no scaling", 25, -2, 2, 25, -TMath::PiOver2(), 3*TMath::PiOver2());
   
   
   
   //QA Histograms
   
   kaonPtDist      = new TH1D("Kaon Pt Distribution", "Kaon Pt Distribution", 1000, 0, 5);
   pionPtDist      = new TH1D("Pion Pt Distribution", "Pion Pt Distribution", 1000, 0, 5);
   kaonEtaDist     = new TH1D("Kaon Eta Distribution", "Kaon Eta Distribution", 1000, -1, 1);
   pionEtaDist     = new TH1D("Pion Eta Distribution", "Pion Eta Distribution", 1000, -1, 1);
   kaonPhiDist     = new TH1D("Kaon Phi Distribution", "Kaon Phi Distribution", 1000, -2*TMath::Pi(), 2*TMath::Pi());
   pionPhiDist     = new TH1D("Pion Phi Distribution", "Pion Phi Distribution", 1000, -2*TMath::Pi(), 2*TMath::Pi());
   kaonDCAprimary  = new TH1D("DCA kaons from primary", "DCA kaons from primary", 500, 0.0, 0.5);
   pionDCAprimary  = new TH1D("DCA pions from primary", "DCA pions from primary", 500, 0.0, 0.5);
   
   hadronPtDist    = new TH1D("Inclusive Hadron pt", "Inclusive Hadron pt", 1000, 0, 10);
   hadronPhiDist   = new TH1D("Inclusive Hadron Phi", "Inclusive Hadron Phi", 1000, -2*TMath::Pi(), 2*TMath::Pi());
   hadronEtaDist   = new TH1D("Inclusvie Hadron Eta", "Inclusive Hadron Eta", 1000, -1, 1);
   

   kaonDCAfromD0   = new TH1D("DCA for kaons from D0", "DCA for kaons from D0", 500, 0.0, 0.5);
   pionDCAfromD0   = new TH1D("DCA for pions from D0", "DCA for pions from D0", 500, 0.0, 0.65);
   decayLengthQA   = new TH1D("D0 Candidate Decay Length (no mass cut)", "D0 Candidate Decay Length (no mass cut)", 500, 0.0, 1.5);
   pointingAngleQA = new TH1D("D0 Candidate Pointing Angle(no mass cut)", "D0 Candidate Pointing Angle (no mass cut)", 500, 0.0, 1.7);
   daughterDCAQA   = new TH1D("D0 Daughter DCA", "D0 Daughter DCA (no mass cut)", 500, 0.0, .01);

   //QA for mass-cut D0  

   D0ptDist        = new TH1D("D0 Candidate pt Dist (mass cut)", "D0 Candidate pt Dist (mass cut)", 1000, 0, 10);
   D0EtaDist       = new TH1D("D0 Eta Dist", "D0 #eta Dist. (mass cut)", 500, -1, 1);
   D0PhiDist       = new TH1D("D0 Phi Dist", "D0 #phi Dist. (mass cut)", 500, -2*TMath::Pi(), 2*TMath::Pi());
   D0PeakPlusBG    = new TH1D("D0 Peak + BG", "D0 Peak + BG", 50, 1.6, 2.1);
   D0LikeSignBG    = new TH1D("LikeSign peak range", "LikeSign peak range", 50, 1.6, 2.1);
   D0PeakMinusBG   = new TH1D("D0 Peak", "D0 Peak", 50, 1.6, 2.1);

   eventCounter    = new TH1D("number of events used", "number of events used", 3, 0, 3);
   trackCounter    = new TH1D("number of tracks per event", "number of tracks per event", 2000, 0, 1999);
   
   d0CountPerEvent = new TH1I("number of D0 candidates per event", "number of D0 candidates per event", 50, 0, 50);
   
   //Histogram formatting

   eventCounter->GetXaxis()->SetBinLabel(1,"minBias");
   eventCounter->GetXaxis()->SetBinLabel(2,"total");
   eventCounter->GetXaxis()->SetBinLabel(3,"events from bad runs");
   
   
   
   
   //Mixed event histograms
   
   mixedEventTest = new TH1D("mixed event test", "mixed event test", 2000, 0, 1999);
   
   mixedHadronPtDist  = new TH1D("mixed Hadron pt", "mixed Hadron pt", 1000, 0, 10);
   mixedHadronPhiDist = new TH1D("mixed Hadron Phi", "mixed Hadron Phi", 1000, -2*TMath::Pi(), 2*TMath::Pi());
   mixedHadronEtaDist = new TH1D("mixed Hadron Eta", "mixed Hadron Eta", 1000, -1, 1);
   
   mixedEventKPInvMass = new TH1D("mixed event KP inv mass", "mixed event KP inv mass", 50, 1.6, 2.1);
   
   mixedEventAngCorr2DAll  = new TH2D("2D Ang Corr mixed event", "2D Ang Corr mixed event", 25, -2, 2, 25, -TMath::PiOver2(), 3*TMath::PiOver2());
   
   fullCorr = new TH2D("fullCorr", "fullCorr", 25, -2, 2, 25, -TMath::PiOver2(), 3*TMath::PiOver2());
   
   
   
   //----------------------End User Variables------------------------------------
   
   
   DEBUG = false;
   DEBUG_MIX_BUFFER = false;
   
   
   return kStOK;
}

//-----------------------------------------------------------------------------

//------------------------------------Destructor------------------------------
StPicoD0AnaMaker::~StPicoD0AnaMaker()
{
   /*  */
}
//-----------------------------------------------------------------------------

//------------------------------------Finish-----------------------------------
Int_t StPicoD0AnaMaker::Finish()
{
   LOG_INFO << " StPicoD0AnaMaker - writing data and closing output file " <<endm;
   mOutputFile->cd();
   // save user variables here
   
   StMixerEvent* event;
   StMixerTrack mixedTrack;
   StMixerTrack kaonPionTrack;
   int nTracks = 0;
   
        for(int i = 0; i < eventBuffer[0][0]->getBufferSize(); i++){
            
            event = eventBuffer[0][0]->getEvent(i);
            nTracks = event->getNoTracks();
            mixedEventTest->Fill(nTracks);
            //cout << "nTracks: " << nTracks << endl;
            for(int j = 0; j < nTracks; j++){
            
               mixedTrack = event->getTrack(j);
               mixedHadronPtDist->Fill(mixedTrack.gMom().perp());
            }
            
            //cout << event->getKaonPionListSize() << endl;
            
            for (int idx = 0; idx < event->getKaonPionListSize(); idx++){
   
                kaonPionTrack = event->getKaonPionAt(idx);
                //cout << "D0 Mass: " << kaonPionTrack.mass() << endl;
   
                mixedEventKPInvMass->Fill(kaonPionTrack.mass());
            
            }    
   
           
   
   }
        
   //Final histogram calculations done here     
      
   double numSib = angCorr2DAll->Integral(1,25,1,25);
   double numMix = mixedEventAngCorr2DAll->Integral(1,25,1,25);

   angCorr2DAll->Scale(numMix/numSib);

   fullCorr->Add(angCorr2DAll, mixedEventAngCorr2DAll, 1, -1);   
   
   fullCorr->Divide(mixedEventAngCorr2DAll);
   
  
   //ptDist->Write();
   invMass->Write();
   kaonDist->Write();
   pionDist->Write();
   likeSignBG->Write();
   angCorrEta->Write();
   angCorrPhi->Write();
   angCorr2DAll->Write();
   invMassMinusBG->Write();
   D0EtaDist->Write();
   D0PhiDist->Write();
   D0PeakMinusBG->Write();
   eventCounter->Write();
   kaonDCAfromD0->Write();
   pionDCAfromD0->Write();
   decayLengthQA->Write();
   pointingAngleQA->Write();
   daughterDCAQA->Write();
   D0ptDist->Write();   
   kaonPtDist->Write();
   pionPtDist->Write();
   kaonEtaDist->Write();
   pionEtaDist->Write();
   kaonPhiDist->Write();
   pionPhiDist->Write();
   kaonDCAprimary->Write();
   pionDCAprimary->Write();
     
   /*angCorrPhiBin1->Write();
   angCorrEtaBin1->Write();
   angCorr2DBin1->Write();
   angCorrPhiBin2->Write();
   angCorrEtaBin2->Write();
   angCorr2DBin2->Write();
   angCorrPhiBin3->Write();
   angCorrEtaBin3->Write();
   angCorr2DBin3->Write();
   angCorrPhiBin4->Write();
   angCorrEtaBin4->Write();
   angCorr2DBin4->Write();
   angCorrPhiBin5->Write();
   angCorrEtaBin5->Write();
   angCorr2DBin5->Write();*/
   hadronPtDist->Write();
   hadronPhiDist->Write();
   hadronEtaDist->Write();
   /*invMassBin1->Write();
   invMassBin2->Write();
   invMassBin3->Write();
   invMassBin4->Write();
   invMassBin5->Write();    
   likeSignBin1->Write();
   likeSignBin2->Write();
   likeSignBin3->Write();
   likeSignBin4->Write();
   likeSignBin5->Write();
   USminusLSBin1->Write();
   USminusLSBin2->Write();
   USminusLSBin3->Write();
   USminusLSBin4->Write();
   USminusLSBin5->Write();*/
   D0PeakPlusBG->Write();
   D0LikeSignBG->Write();
   trackCounter->Write();
   
   mixedEventTest->Write();
   mixedHadronPtDist->Write();
   mixedHadronPhiDist->Write();
   mixedHadronEtaDist->Write();
   mixedEventKPInvMass->Write();
   mixedEventAngCorr2DAll->Write();
   fullCorr->Write();
   
   d0CountPerEvent->Write();
   
   siblingCorr->Write();

   mOutputFile->Close();
  

   return kStOK;
}
//-----------------------------------------------------------------------------

//----------------------------------Make---------------------------------------
Int_t StPicoD0AnaMaker::Make()
{
   readNextEvent();

   if (!mPicoDstMaker)
   {
      LOG_WARN << " StPicoD0AnaMaker - No PicoDstMaker! Skip! " << endm;
      return kStWarn;
   }

   StPicoDst const* picoDst = mPicoDstMaker->picoDst();


   if (!picoDst)
   {
      LOG_WARN << "StPicoD0AnaMaker - No PicoDst! Skip! " << endm;
      return kStWarn;
   }

   if(mPicoD0Event->runId() != picoDst->event()->runId() ||
       mPicoD0Event->eventId() != picoDst->event()->eventId())
   {
     LOG_ERROR <<" StPicoD0AnaMaker - !!!!!!!!!!!! ATTENTION !!!!!!!!!!!!!"<<endm;
     LOG_ERROR <<" StPicoD0AnaMaker - SOMETHING TERRIBLE JUST HAPPENED. StPicoEvent and StPicoD0Event are not in sync."<<endm;
     exit(1);
   }

   //-------------------Begin User Analysis---------------------------
    
    //-------------- Various cuts and pt ranges---------------- ::::::::Need to eventually move this into an input file OR into the macro somehow
    
    
   

    double kaonPtCut      = .15;
    double pionPtCut      = .15;
    
    double D0InvMassLow   = 1.82;
    double D0InvMassHigh  = 1.90;
	//--------------------------------------------
    
    //Variables used in the code
    double delPhi         = 0;
    double delEta         = 0;
    double pt             = 0;
    double phi            = 0;
    double eta            = 0;
    StPicoTrack* trk;
    StThreeVectorF trackMom;
    double bField         = picoDst->event()->bField();
    StThreeVectorF pVtx   = picoDst->event()->primaryVertex();
    StThreeVectorF kaonPionMom;
    /////////////////////////////
    
    bool eventStoredInBuffer  = false;
    int trackCount = 0;
    int centralityBin = 0;  //This number will be between 0 and 8 -- 9 bins total
    
    int d0Counter = 0;
//---------------------------------------------------------------------------------    
    
 // if(!mHFCuts->isGoodEvent(const_cast<const StPicoDst*>(picoDst), NULL)) return kStOk; //makes sure the event comes from good run
  if(!mHFCuts->isGoodRun(picoDst->event())){
      
      eventCounter->Fill(1);
      eventCounter->Fill(2);
      return kStOk; //makes sure the event comes from good run
  }

  eventCounter->Fill(1);
  if(!picoDst->event()->isMinBias()) {return kStOK;}          //min bias event flag
  //if(!picoDst->event()->isCentral()) {return kStOK;}          //central events flag ---- What are the criteria for central events
  eventCounter->Fill(0);

  if(mPicoD0Event->nKaons() > 0){ kaonDist->Fill(mPicoD0Event->nKaons());}
  if(mPicoD0Event->nPions() > 0){ pionDist->Fill(mPicoD0Event->nPions());}

  //Fill kaon and pion pt dist
  

   TClonesArray const * aKaonPion = mPicoD0Event->kaonPionArray();                     //The Kaon-Pion list is generated here

   trackCount = picoDst->numberOfTracks();
   
   trackCounter->Fill(picoDst->numberOfTracks());
   
  if(DEBUG) { 
        
        cout << endl << endl;
        cout << "*********************EVENT START******************" << endl;
        cout << "We are on event # " << eventNumber << endl;
        cout << "This event has " << trackCount << " tracks." << endl;
        cout << endl;
  
  }     
   /********************ALL GENERAL EVENT STATS SHOULD BE COLLECTED IN THIS BLOCK*************************************************************/
   
   //Still need to add checks for TOF information-----
  
  
/********************QA Loop for storing all of the basic information about the events and tracks ******************/
   
   for(unsigned int i = 0; i < picoDst->numberOfTracks(); ++i){ // Begin QA loop

          trk = picoDst->track(i);
          trackMom = trk->gMom(pVtx, bField);
          //pt = TMath::Sqrt((trk->pMom().x()*trk->pMom().x())+(trk->pMom().y()*trk->pMom().y()));
          //phi = trk->pMom().phi();  
          //eta = trk->pMom().pseudoRapidity();
          
          pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y()));
          phi = TMath::ATan2(trackMom.y(),trackMom.x());  
          eta = trackMom.pseudoRapidity();
          
		  //I think here is where I will store the tracks into the event buffer.
		  
          //if(pt<.15){continue;}                                                   //Basic cut to ensure the tracks are in the TPC acceptance.
          
          hadronPtDist->Fill(pt);                                                 //Fill pt dist. for all hadrons
          hadronPhiDist->Fill(phi);                                               //fill hists with phi and eta of hadrons for QA
          hadronEtaDist->Fill(eta);
   
          if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaKaon()) < 2.0)){       //ONLY check nSigma for TPC track -- used to be mHFCuts->isTPCKaon(trk), but this include pt cut
                                                                                  //need to fix this. Need to figure out how to access the nSigma from the cuts
                kaonPtDist->Fill(pt);
                kaonEtaDist->Fill(eta);
                kaonPhiDist->Fill(phi);
               // kaonDCAprimary->Fill(      
                continue;
          }

          if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaPion()) < 3.0)){     //ONLY check nSigma for TPC track
                
                pionPtDist->Fill(pt);
                pionEtaDist->Fill(eta);
                pionPhiDist->Fill(phi);
               // pionDCAprimary->Fill(
                continue;
          }
          
          
          
       }// end QA Loop
   
/******************************************************************************************************************/
   
   
/********************Loop to check for a D0 candidate in the event and mark a flag to store events in mixer if so*******/
   
   for (int idx = 0; idx < aKaonPion->GetEntries(); ++idx){
   
        StKaonPion const* kp = (StKaonPion*)aKaonPion->At(idx);
        StPicoTrack const* kaon = picoDst->track(kp->kaonIdx());
        StPicoTrack const* pion = picoDst->track(kp->pionIdx());
   
        if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh && kaon->charge()*pion->charge() < 0){ 
            
            eventBuffer[0][0]->addEvent(picoDst);
            eventStoredInBuffer = true; 
            if(DEBUG){ cout << "event " << eventNumber << " stored." << endl; }
            break;
        }
   
   }
   
   
   int PIDflag = 0;
   
   //This block stores the tracks in the buffer and then stores the kaonPion pairs in the buffer in a separate list
    if(eventStoredInBuffer){
    
        for(unsigned int i = 0; i < picoDst->numberOfTracks(); ++i){
    
            trk = picoDst->track(i);                                                             
           	trackMom = trk->gMom(pVtx, bField); 
            //add 
            if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaKaon()) < 2.0)){ PIDflag = 1; }
            else if(mHFCuts->isGoodTrack(trk) && (fabs(trk->nSigmaPion()) < 3.0)) { PIDflag = 2; }
            else PIDflag = 0;
            
            //if(DEBUG){ cout << "Track index: " << i << "   Particle flag: " << PIDflag << "    momentum in GeV: " << trackMom << endl;}
            
            eventBuffer[0][0]->addTrackToEvent(eventBuffer[0][0]->getBufferIndex()-1, trackMom, trk->charge(), PIDflag);   //0 -- any hadron, 1 -- kaon, 2 -- pion
                  
        }//end loop to add tracks to event
        
        int i = 0;
        int buffIdx = 0;
        
        for (int idx = 0; idx < aKaonPion->GetEntries(); ++idx){
   
            StKaonPion const* kp = (StKaonPion*)aKaonPion->At(idx);
            StPicoTrack const* kaon = picoDst->track(kp->kaonIdx());
            StPicoTrack const* pion = picoDst->track(kp->pionIdx());
   
            if(!isGoodPair(kp)) continue; 
            
            if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh && kaon->charge()*pion->charge() < 0){ 
                if(DEBUG_MIX_BUFFER){ 
                    cout << "Actual eta from picoDst: " << kp->eta() << endl;
                    cout << "Kaon index: " << kp->kaonIdx() << "    Pion index: " << kp->pionIdx() << endl;
                }    
                
                kaonPionMom.set(kp->lorentzVector().px(),kp->lorentzVector().py(),kp->lorentzVector().pz());
            
                eventBuffer[0][0]->addKaonPionToEvent(eventBuffer[0][0]->getBufferIndex()-1, kaonPionMom, kp->m(), kp->kaonIdx(), kp->pionIdx());
                
                if(DEBUG_MIX_BUFFER){
                    buffIdx  = eventBuffer[0][0]->getBufferIndex()-1;
                    cout << "eta from buffer: " << eventBuffer[0][0]->getEvent(buffIdx)->getKaonPionAt(i).gMom().pseudoRapidity() << endl;
                    cout << "Kaon buffer index: " << eventBuffer[0][0]->getEvent(buffIdx)->getKaonPionAt(i).kaonIdx() << "    Pion buffer index: " << eventBuffer[0][0]->getEvent(buffIdx)->getKaonPionAt(i).pionIdx() << endl;
                    cout << "______________________________________________________" << endl;
                }   
                
                i++;               
            }
   
        }//end loop to add kaonPions to event
        
    } //eventStoredInBuffer tag
   
   //cout << "total kp candidates stored: " << << endl;
   
/*********************************************************************************************************/   
   
   
   /****************************BEGIN BLOCK USING TREE INFORMATION****************************************************/
   
   for (int idx = 0; idx < aKaonPion->GetEntries(); ++idx){ // begin main loop
     
      // this is an example of how to get the kaonPion pairs and their corresponding tracks
      StKaonPion const* kp = (StKaonPion*)aKaonPion->At(idx);
    
      StPicoTrack const* kaon = picoDst->track(kp->kaonIdx());
      StPicoTrack const* pion = picoDst->track(kp->pionIdx());
      
      if(!isGoodPair(kp)) continue;                    
      
     ////////////////Fill QA Histograms from pair trees //////////////////////

     
     kaonDCAfromD0->Fill(kp->kaonDca());
     pionDCAfromD0->Fill(kp->pionDca());
     decayLengthQA->Fill(kp->decayLength());
     pointingAngleQA->Fill(kp->pointingAngle());
     daughterDCAQA->Fill(kp->dcaDaughters());

     /////////////////////////////////////////////////////////////////////////
     
      //cutCheck(StKaonPion const* const kp, double ptMin, double ptMax, double decayLengthMin, double decayLengthMax, double dcaDaughters, 
      //         double kaonPtCut, double pionPtCut, double dcaKaontoPV, double dcaPiontoPV, double dcaV0toPV)

      //ptDist->Fill(kp->pt());
      if(kaon->charge()*pion->charge() < 0){// begin Unlike-sign conditional 
	      /*if     (cutCheck(kp, pt1, pt2, decayLength1, 999999.0, dcaDaughters1, kaonPtCut, pionPtCut, dcaKaonPV1, dcaPionPV1, dcaV0toPV1)) { invMassBin1->Fill(kp->m()); } 
	      else if(cutCheck(kp, pt2, pt3, decayLength2, 999999.0, dcaDaughters2, kaonPtCut, pionPtCut, dcaKaonPV2, dcaPionPV2, dcaV0toPV2)) { invMassBin2->Fill(kp->m()); }
              else if(cutCheck(kp, pt3, pt4, decayLength3, 999999.0, dcaDaughters3, kaonPtCut, pionPtCut, dcaKaonPV3, dcaPionPV3, dcaV0toPV3)) { invMassBin3->Fill(kp->m()); }     //Fill invmass based on pt of D0
	      else if(cutCheck(kp, pt4, pt5, decayLength4, 999999.0, dcaDaughters4, kaonPtCut, pionPtCut, dcaKaonPV4, dcaPionPV4, dcaV0toPV4)) { invMassBin4->Fill(kp->m()); }
              else if(cutCheck(kp, pt5, pt6, decayLength5, 999999.0, dcaDaughters5, kaonPtCut, pionPtCut, dcaKaonPV5, dcaPionPV5, dcaV0toPV5)) { invMassBin5->Fill(kp->m()); }*/
	  
	  
	      if(kaon->gPt() > 1.2 && pion->gPt() > 1.2 && kp->decayLength() > .0200 && 
                 kp->dcaDaughters() < .0055 && kp->kaonDca() > .008 && 
                 kp->pionDca() > .008 && kp->perpDcaToVtx() < .0065)
                { 
                   invMass->Fill(kp->m());     
                   if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh) { D0PeakPlusBG->Fill(kp->m()); } 
                }     //Pt integrated invmass
	  }//end Unlike-sign conditional 
      
	  
      if(kaon->charge()*pion->charge() > 0){//begin Like-sign conditional 
          /*if     (cutCheck(kp, pt1, pt2, decayLength1, 999999.0, dcaDaughters1, kaonPtCut, pionPtCut, dcaKaonPV1, dcaPionPV1, dcaV0toPV1)) { likeSignBin1->Fill(kp->m()); }
          else if(cutCheck(kp, pt2, pt3, decayLength2, 999999.0, dcaDaughters2, kaonPtCut, pionPtCut, dcaKaonPV2, dcaPionPV2, dcaV0toPV2)) { likeSignBin2->Fill(kp->m()); }
          else if(cutCheck(kp, pt3, pt4, decayLength3, 999999.0, dcaDaughters3, kaonPtCut, pionPtCut, dcaKaonPV3, dcaPionPV3, dcaV0toPV3)) { likeSignBin3->Fill(kp->m()); }     //Fill likesign based on pt of D0
          else if(cutCheck(kp, pt4, pt5, decayLength4, 999999.0, dcaDaughters4, kaonPtCut, pionPtCut, dcaKaonPV4, dcaPionPV4, dcaV0toPV4)) { likeSignBin4->Fill(kp->m()); }
          else if(cutCheck(kp, pt5, pt6, decayLength5, 999999.0, dcaDaughters5, kaonPtCut, pionPtCut, dcaKaonPV5, dcaPionPV5, dcaV0toPV5)) { likeSignBin5->Fill(kp->m()); }*/

          if(kaon->gPt() > 1.2 && pion->gPt() > 1.2 && kp->decayLength() > .0200 && 
             kp->dcaDaughters() < .0055 &&  kp->kaonDca() > .008 && 
             kp->pionDca() > .008 && kp->perpDcaToVtx() < .0065)
                { 
                   likeSignBG->Fill(kp->m());   
                   if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh) { D0LikeSignBG->Fill(kp->m()); }
                }

          }//end Like-sign conditional 
 
            
       
        //This block is for analyzing anything involving just the D0 peak.***************

	if(kp->m() > D0InvMassLow && kp->m() < D0InvMassHigh && kaon->charge()*pion->charge() < 0){ // begin loop over D0 candidates

    
           d0Counter = d0Counter + 1;
           //D0Count->Fill(0);
           D0ptDist->Fill(kp->pt()); 
           D0EtaDist->Fill(kp->eta());
           D0PhiDist->Fill(kp->phi());
           
              //DVec.set(kp->lorentzVector().px(),kp->lorentzVector().py(),kp->lorentzVector().pz());
           
          for(unsigned int i = 0; i < picoDst->numberOfTracks(); ++i){ // begin picoDST loop for d0-hadron correlations
           
         	 if(i == kp->kaonIdx() || i == kp->pionIdx()) { continue; }                                // Need to check this -- should avoid doing correlations with a D0 candidate daughter
                    
                    ////////NEED TO ADD SOMETHING TO REJECT ELECTRONS AND MUONS///////////
                
          	        trk = picoDst->track(i);                                                             //extract track from picoDst and store as StPicoTrack
           	        
                    trackMom = trk->gMom(pVtx, bField);
               
                    //Calculate kinematic variables
               
                    pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); //calculate tranverse momentum of track
                    
                    //if(pt < 1.0 ) { continue; }                                                 //Ensure track is within TPC acceptance and choose a specific sample of hadrons.
                                                                                
                    phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                    eta = trackMom.pseudoRapidity();
                 
                    delPhi = kp->phi()-phi;
                    if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
             	       else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                    //eta = trackMom.pseudoRapidity();
                    delEta =kp->eta()-eta;
                   
                 //if(kp->decayLength() > .0200 && kp->dcaDaughters() < .0055 && kp->kaonDca() > .008 && kp->pionDca() > .008 && 
                    //kp->kaonDca() > .008 && kp->pionDca() > .008 && kp->perpDcaToVtx() < .0065){ //D0 track cuts for pt-inclusive sibling dist.
                    angCorrPhi->Fill(delPhi);
                    angCorrEta->Fill(delEta);
                    angCorr2DAll->Fill(delEta, delPhi);
                    siblingCorr->Fill(delEta, delPhi);
                 //}
                
                 
             } // end picoDST loop for d0-hadron correlations
        }// End d0 conditional

        
       
    }// End main Loop

    
    /*************************************EVENT MIXING HAPPENS HERE**************************************************/
    
    if(eventBuffer[0][0]->getBufferMaxSize() == eventBuffer[0][0]->getBufferSize()){//eventBuffer[0][0]->getBufferMaxSize() == eventBuffer[0][0]->getBufferSize()){ eventBuffer[0][0]->getBufferMaxSize() == 10
    
        //cout << "MIXING EVENTS!!!!" << endl;
    
        StMixerEvent* event1;
        StMixerEvent* event2;
        StMixerEvent* event3;
        
        StMixerTrack kaonPionTrack1;
        StMixerTrack mixedTrack2;
        StMixerTrack mixedTrack3;
        
        int nTracks1 = 0;
        int nTracks2 = 0;
        int nTracks3 = 0;
        
        //cout << "Before first loop in mixer" << endl;
        
        for(int i = 0; i < eventBuffer[0][0]->getBufferSize(); i++){
            
            
            if( i < eventBuffer[0][0]->getBufferSize()-2)  //for 5 events, this means i is 0, 1, 2
            {
                event1 = eventBuffer[0][0]->getEvent(i);
                event2 = eventBuffer[0][0]->getEvent(i+1);
                event3 = eventBuffer[0][0]->getEvent(i+2);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing events in buffer " << i << " with " << i+1 << "  and " << i+2 << endl;}
            }    
            
            else if(i == eventBuffer[0][0]->getBufferSize()-2)  //for 5 events, this means i is 3, 4, 0
            {
                event1 = eventBuffer[0][0]->getEvent(i);
                event2 = eventBuffer[0][0]->getEvent(i+1);
                event3 = eventBuffer[0][0]->getEvent(0);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing events in buffer " << i << " with " << i+1 << "  and 0 " <<  endl;}
            }    
                
            else if(i == eventBuffer[0][0]->getBufferSize()-1)  //for 5 events, this means i is 4, 0, 1
            {
                event1 = eventBuffer[0][0]->getEvent(i);
                event2 = eventBuffer[0][0]->getEvent(0);
                event3 = eventBuffer[0][0]->getEvent(1);
                nTracks1 = event1->getNoTracks();
                nTracks2 = event2->getNoTracks();
                nTracks3 = event3->getNoTracks();
                
                if(DEBUG_MIX_BUFFER){cout << "mixing events in buffer " << i << " with 0 and 1 "<<  endl;}
            }    
            
            
            
            //cout << "mixing events in buffer " << i << "  and buffer  " << i+1 << endl;
            
            
            for (int idx = 0; idx < event1->getKaonPionListSize(); idx++){
                
                kaonPionTrack1 = event1->getKaonPionAt(idx);
                StMixerTrack mixerKaon = event1->getTrack(kaonPionTrack1.kaonIdx());
                StMixerTrack mixerPion = event1->getTrack(kaonPionTrack1.pionIdx());
                
                //cout <<  "nTracks1: " << nTracks1 << "   nTracks2: " << nTracks2 << "     kaonPionListSize:  " << event1->getKaonPionListSize() <<  endl;
                //cout << "Kaon Index: " << kaonPionTrack1.kaonIdx() << "    Pion index: " << kaonPionTrack1.pionIdx() << endl;
                
                if(kaonPionTrack1.mass() > D0InvMassLow && kaonPionTrack1.mass() < D0InvMassHigh && mixerKaon.charge()*mixerPion.charge() < 0){
                 
                    for(int j = 0; j < nTracks2; j++){
                        
                        if(j == kaonPionTrack1.kaonIdx() || j == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack2 = event2->getTrack(j);                                                            
           	        
                        trackMom = mixedTrack2.gMom();
               
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                    
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        eta = trackMom.pseudoRapidity();
                        delEta =kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        //if(kp->decayLength() > .0200 && kp->dcaDaughters() < .0055 && kp->kaonDca() > .008 && kp->pionDca() > .008 && 
                                                            //kp->kaonDca() > .008 && kp->pionDca() > .008 && kp->perpDcaToVtx() < .0065){ //D0 track cuts for pt-inclusive sibling dist.
                
                            mixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            
                        //}
                    
                    }//end loop over event 2 tracks
                    
                    
                    for(int k = 0; k < nTracks3; k++){
                        
                        if(k == kaonPionTrack1.kaonIdx() || k == kaonPionTrack1.pionIdx()) { continue; }                                
                        
                        mixedTrack3 = event3->getTrack(k);                                                            
           	        
                        trackMom = mixedTrack3.gMom();
               
                        pt = TMath::Sqrt((trackMom.x()*trackMom.x())+(trackMom.y()*trackMom.y())); 
                    
                        phi = TMath::ATan2(trackMom.y(),trackMom.x());  
                
                 
                        delPhi = kaonPionTrack1.gMom().phi()-phi;
                        if(delPhi < -TMath::PiOver2()){ delPhi = delPhi + 2*TMath::Pi(); }
                            else if(delPhi >= 3*TMath::PiOver2()){ delPhi = delPhi - 2*TMath::Pi(); }
                
                        eta = trackMom.pseudoRapidity();
                        delEta =kaonPionTrack1.gMom().pseudoRapidity()-eta;
                
                        //if(kp->decayLength() > .0200 && kp->dcaDaughters() < .0055 && kp->kaonDca() > .008 && kp->pionDca() > .008 && 
                                                            //kp->kaonDca() > .008 && kp->pionDca() > .008 && kp->perpDcaToVtx() < .0065){ //D0 track cuts for pt-inclusive sibling dist.
                
                            mixedEventAngCorr2DAll->Fill(delEta, delPhi);
                            
                        //}
                    
                    }//end loop over event 3 tracks
                
                }//end conditional for d0
                
            }//end loop over event 1 kaon-pion list
       
       }//end event buffer loop   
    
      //for(int i = 0; i < eventBuffer[0][0]->getBufferSize()-1; i++)
      eventBuffer[0][0]->clearBuffer();
      eventBuffer[0][0]->setBufferCounter(0);
      
      if(DEBUG) { 
        
        cout << endl << endl;
        cout << "buffer cleared" << endl;
        cout << endl;
  
      }     
      
      
      

     }//end buffer-full mixing conditional
    
    
       d0CountPerEvent->Fill(d0Counter);
       
       //cout << d0Counter << endl;
       
       invMassMinusBG->Add(invMass, likeSignBG, 1, -1);
       /*USminusLSBin1->Add(invMassBin1, likeSignBin1, 1, -1);
       USminusLSBin2->Add(invMassBin2, likeSignBin2, 1, -1);
       USminusLSBin3->Add(invMassBin3, likeSignBin3, 1, -1);
       USminusLSBin4->Add(invMassBin4, likeSignBin4, 1, -1);
       USminusLSBin5->Add(invMassBin5, likeSignBin5, 1, -1);*/
       D0PeakMinusBG->Add(D0PeakPlusBG, D0LikeSignBG, 1, -1);
    
    
    
    //if(eventBuffer[0][0]->getBufferMaxSize() == eventBuffer[0][0]->getBufferIndex()) {mixEvents = false;}
    
    //cout << "buffer max: " << eventBuffer[0][0]->getBufferMaxSize() << "  Buffer index: " << eventBuffer[0][0]->getBufferIndex() << endl;
    
   
    eventNumber++;
    
   //-------------------End User Analysis--------------------------------
   
   return kStOK;
}

//---------------------User Functions-------------------------------------

bool StPicoD0AnaMaker::isGoodPair(StKaonPion const* const kp) const
{
  if(!kp) return false;

  StPicoTrack const* kaon = mPicoDstMaker->picoDst()->track(kp->kaonIdx());
  StPicoTrack const* pion = mPicoDstMaker->picoDst()->track(kp->pionIdx());

  //  To be replaced by mHFCuts->isGoodSecondaryVertexPair(kp))
  bool pairCuts = kp->m() > mHFCuts->cutSecondaryPairMassMin() && 
    kp->m() < mHFCuts->cutSecondaryPairMassMax() &&
    std::cos(kp->pointingAngle()) > mHFCuts->cutSecondaryPairCosThetaMin() &&
    kp->decayLength()  > mHFCuts->cutSecondaryPairDecayLengthMin() && 
    kp->decayLength()  < mHFCuts->cutSecondaryPairDecayLengthMax() &&
    kp->dcaDaughters() < mHFCuts->cutSecondaryPairDcaDaughtersMax();

  return (mHFCuts->isGoodTrack(kaon) && mHFCuts->isGoodTrack(pion) &&
	  mHFCuts->isTPCKaon(kaon) && mHFCuts->isTPCPion(pion) && 
	  pairCuts);

}


bool StPicoD0AnaMaker::cutCheck(StKaonPion const* const kp, double ptMin, double ptMax, double decayLengthMin, double decayLengthMax, 
                                                            double dcaDaughters, double kaonPtCut, double pionPtCut, 
                                                            double dcaKaon, double dcaPion, double dcaV0toPV) const
{
  if(!kp) return false;

  StPicoTrack const* kaon = mPicoDstMaker->picoDst()->track(kp->kaonIdx());
  StPicoTrack const* pion = mPicoDstMaker->picoDst()->track(kp->pionIdx());

  
      bool truthCuts = kp->pt() > ptMin && kp->pt() < ptMax &&
                       kp->decayLength() > decayLengthMin && 
                       kp->decayLength() < decayLengthMax &&
                       kp->dcaDaughters() < dcaDaughters  &&
                       kaon->gPt() > kaonPtCut && pion->gPt() > pionPtCut &&
                       kp->kaonDca() > dcaKaon && kp->pionDca() > dcaPion &&
                       kp->perpDcaToVtx() < dcaV0toPV;
  
      return truthCuts;

}






//OLD CODE THAT I MAY NEED WHILE I DO UPDATES

/*double pt1            = 0.0;
    double pt2            = 1.0;                               // :::::::: May be better to store this stuff in a series of arrays.
    double pt3            = 2.0;
    double pt4            = 3.0;
    double pt5            = 5.0;
    double pt6            = 10.0;*/

/* double decayLength1   = .0145;
    double decayLength2   = .0181;
    double decayLength3   = .0212;
    double decayLength4   = .0247;
    double decayLength5   = .0259;*/
    
     /*double dcaDaughters1  = .0084;
    double dcaDaughters2  = .0066;
    double dcaDaughters3  = .0057;
    double dcaDaughters4  = .0050;
    double dcaDaughters5  = .0060;*/
    
     /*double dcaKaonPV1     = .0103;
    double dcaKaonPV2     = .0091;
    double dcaKaonPV3     = .0095;
    double dcaKaonPV4     = .0079;
    double dcaKaonPV5     = .0058;*/
    
    /*double dcaPionPV1     = .0110;
    double dcaPionPV2     = .0111;
    double dcaPionPV3     = .0086;
    double dcaPionPV4     = .0081;
    double dcaPionPV5     = .0062;*/
    
     /*double dcaV0toPV1     = .0061;
    double dcaV0toPV2     = .0049;
    double dcaV0toPV3     = .0038;
    double dcaV0toPV4     = .0038;
    double dcaV0toPV5     = .0040;*/
    
    
     /*double ptRange[6] = {0.0, 1.0, 2.0, 3.0, 5.0, 10.0};
    double decayLengthCuts[5] = {.0145, .0181, .0212, .0247, .0259};
    double daughterDCACuts[5] = {.0084, .0066, .0057, .0050, .0060};
    double dcaKaonPV[5] = {.0103, .0091, .0095, .0079, .0058};
    double dcaPionPV[5] = {.0110, .0111, .0086, .0081, .0062};
    double dcaV0toPV[5] = {.0061, .0049, .0038, .0038, .0040};*/
    
    
    /*invMassBin1      = new TH1D("unlikeSign_bin1", "unlikeSign_bin1", 50, 1.6, 2.1);
   invMassBin2      = new TH1D("unlikeSign_bin2", "unlikeSign_bin2", 50, 1.6, 2.1);
   invMassBin3      = new TH1D("unlikeSign_bin3", "unlikeSign_bin3", 50, 1.6, 2.1);
   invMassBin4      = new TH1D("unlikeSign_bin4", "unlikeSign_bin4", 50, 1.6, 2.1);
   invMassBin5      = new TH1D("unlikeSign_bin5", "unlikeSign_bin5", 50, 1.6, 2.1);

   likeSignBin1     = new TH1D("likeSign_bin1", "likeSign_bin1", 50, 1.6, 2.1);
   likeSignBin2     = new TH1D("likeSign_bin2", "likeSign_bin2", 50, 1.6, 2.1);
   likeSignBin3     = new TH1D("likeSign_bin3", "likeSign_bin3", 50, 1.6, 2.1);
   likeSignBin4     = new TH1D("likeSign_bin4", "likeSign_bin4", 50, 1.6, 2.1);
   likeSignBin5     = new TH1D("likeSign_bin5", "likeSign_bin5", 50, 1.6, 2.1);

   USminusLSBin1    = new TH1D("US-LS_bin1", "US-LS_bin1", 50, 1.6, 2.1);
   USminusLSBin2    = new TH1D("US-LS_bin2", "US-LS_bin2", 50, 1.6, 2.1);
   USminusLSBin3    = new TH1D("US-LS_bin3", "US-LS_bin3", 50, 1.6, 2.1);
   USminusLSBin4    = new TH1D("US-LS_bin4", "US-LS_bin4", 50, 1.6, 2.1);
   USminusLSBin5    = new TH1D("US-LS_bin5", "US-LS_bin5", 50, 1.6, 2.1);*/


   /*angCorrPhiBin1   = new TH1D("#Delta Phi bin 1", "#Delta#phi bin 1", 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEtaBin1   = new TH1D("#Delta#Eta bin 1", "#Delta#eta bin 1", 100, -2 , 2);
   angCorr2DBin1    = new TH2D("2D Ang Corr bin 1", "2D Ang Corr bin 1", 100, -2, 2, 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrPhiBin2   = new TH1D("#Delta Phi bin 2", "#Delta#phi bin 2", 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEtaBin2   = new TH1D("#Delta#Eta bin 2", "#Delta#eta bin 2", 100, -2 , 2);
   angCorr2DBin2    = new TH2D("2D Ang Corr bin 2", "2D Ang Corr bin 2", 100, -2, 2, 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrPhiBin3   = new TH1D("#Delta Phi bin 3", "#Delta#phi bin 3", 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEtaBin3   = new TH1D("#Delta#Eta bin 3", "#Delta#eta bin 3", 100, -2 , 2);
   angCorr2DBin3    = new TH2D("2D Ang Corr bin 3", "2D Ang Corr bin 3", 100, -2, 2, 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrPhiBin4   = new TH1D("#Delta Phi bin 4", "#Delta#phi bin 4", 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEtaBin4   = new TH1D("#Delta#Eta bin 4", "#Delta#eta bin 4", 100, -2 , 2);
   angCorr2DBin4    = new TH2D("2D Ang Corr bin 4", "2D Ang Corr bin 4", 100, -2, 2, 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrPhiBin5   = new TH1D("#Delta Phi bin 5", "#Delta#phi bin 5", 100, -TMath::PiOver2(), 3*TMath::PiOver2());
   angCorrEtaBin5   = new TH1D("#Delta#Eta bin 5", "#Delta#eta bin 5", 100, -2 , 2);
   angCorr2DBin5    = new TH2D("2D Ang Corr bin 5", "2D Ang Corr bin 5", 100, -2, 2, 100, -TMath::PiOver2(), 3*TMath::PiOver2());*/
   
   
   //pt bins for D0 pt -- NEED TO WRITE A FUNCTION TO DO THESE CUT CHECKS
                /*if(cutCheck(kp, pt1, pt2, decayLength1, 999999, dcaDaughters1, 0.0, 0.0, dcaKaonPV1, dcaPionPV1, dcaV0toPV1)){
                    angCorrPhiBin1->Fill(delPhi);
                    angCorrEtaBin1->Fill(delEta);
                    angCorr2DBin1->Fill(delEta, delPhi); 
                }
                    else if(cutCheck(kp, pt2, pt3, decayLength2, 999999, dcaDaughters2, 0.0, 0.0, dcaKaonPV2, dcaPionPV2, dcaV0toPV2)){
                        angCorrPhiBin2->Fill(delPhi);
                        angCorrEtaBin2->Fill(delEta);
                        angCorr2DBin2->Fill(delEta, delPhi);
                    }
                    else if(cutCheck(kp, pt3, pt4, decayLength3, 999999, dcaDaughters3, 0.0, 0.0, dcaKaonPV3, dcaPionPV3, dcaV0toPV3)){ 
                        angCorrPhiBin3->Fill(delPhi);
                        angCorrEtaBin3->Fill(delEta);
                        angCorr2DBin3->Fill(delEta, delPhi);
                    }
                    else if(cutCheck(kp, pt4, pt5, decayLength4, 999999, dcaDaughters4, 0.0, 0.0, dcaKaonPV4, dcaPionPV4, dcaV0toPV4)){
                        angCorrPhiBin4->Fill(delPhi);
                        angCorrEtaBin4->Fill(delEta);
                        angCorr2DBin4->Fill(delEta, delPhi);
                    }
                    else if(cutCheck(kp, pt5, pt6, decayLength5, 999999, dcaDaughters5, 0.0, 0.0, dcaKaonPV5, dcaPionPV5, dcaV0toPV5)){ 
                        angCorrPhiBin5->Fill(delPhi);
                        angCorrEtaBin5->Fill(delEta);
                        angCorr2DBin5->Fill(delEta, delPhi);
                    }  */
